---
title: Intro to procedural animations
---

import Node from '../../../../components/Node.astro';
import {Image} from 'astro:assets';
import simpleGraphImg from 'assets/opacitygraph.png';
import sophGraphImg from 'assets/bopGraph.png';
import resVideo from 'assets/opacity.webm';
import bopVideo from 'assets/bop.webm';

This guide introduces procedural animations, explains why they matter, and how to create both simple and complex animations using nodes.

:::tip
Before diving in, you may find it helpful to review the <a href="/docs/usage/animating/getting-started">Basics of Animations</a> and <a href="/docs/usage/node-graph/getting-started-with-node-graph">Getting Started with Node Graphs</a> pages first.
:::


## What is procedural animation

Procedural animation refers to animations that are generated based on logic and input parameters. It's important to not confuse this with generative AI (such as ChatGPT), as those make use of prompts instead. 


## Key animation nodes 

The following nodes are essential when working with procedural animations:
- **Time node:** Provides the current position in the animation timeline. It exposes:
  - **Active Frame:** The current frame being displayed.
  - **Normalized Time;** A value between `0.0` (start of animation) and `1.0` (end of animation).  

    <a style={{textDecoration: "none"}} href="/docs/usage/node-graph/nodes/animation/time"><Node data={{
      name: 'Time',
    category: "Animation",
    icon: "icon-clock",
    isPair: false,
    hasPreview: false,
    inputs: null,
    outputs: [
          {
          name: "Active Frame",
          type: "Integer",
          description: 'The current active frame in the timeline.',
          isContextful: false,
          default: '0'
          },
    { 
      name: "Normalized Time",
      type: "Double",
      description: 'The normalized time value, ranging from 0.0 to 1.0, representing the current position in the timeline relative to the total duration.',
      isContextful: false,
      default: '0.0'}],
    description: 'Provides the current time in the animation timeline, including the active frame and normalized time.'
    }}/></a>
  
<br/>

- **Easing node** - Easing applies smooth transitions to animations, such as ease-in, ease-out, or elastic effects.

    <a style={{textDecoration: "none"}} href="/docs/usage/node-graph/nodes/animation/easing"><Node data={{
      name: "Easing ",
      category: "Animation",
      icon: "icon-spline-chart",
      isPair: false,
      hasPreview: false,
      inputs: [
        {
          name: "Value",
          type: "Double",
          description: "The input value to be eased. This value should be between 0 and 1.",
          isContextful: true,
          default: "0.0"
        },
        {
          name: "Easing Type",
          type: "EasingType (Enum)",
          hideSocket: true,
          typeLink: "/docs/usage/node-graph/nodes/animation/easing#easing-types",
          description: "The type of easing function to apply to the input value. This determines how the value transitions over time.",
          isContextful: false,
          default: "Linear"
        }
      ],
      outputs: [
        {
          name: "Output",
          type: "Double",
          description: "The eased output value, which is the result of applying the selected easing function to the input value.",
          isContextful: true,
          default: "0.0"
        }
      ],
      description: "Applies an easing function to a value, transforming it based on the selected easing type. This is useful for creating smooth transitions in animations."
    }}/></a>

<br/>

:::note  
Other nodes in the Animation category are also useful and can be combined to create unique effects.  
:::



## Create a basic procedural animation

Follow these steps to create a simple opacity animation:

1. Connect the **Normalized Time** node to **Output** under the image node. 

  <Image src={simpleGraphImg} alt="Simple graph that connects Normalized Time of Time Node to Layer's Opacity input"/>

2. Use the **Normalized Time** output to track animation progress. For example, in a 2-second animation, the normalized time at 1 second is **0.5**. 



### The result
This produces a smooth fade-in effect over the duration of the animation.
  - At the beginning (0), the image is fully transparent.
  - At the end (1), the image is fully opaque.

  <video src={resVideo} muted autoplay loop/>



## Create a more complex procedural animation
You can chain multiple nodes together to create advanced effects. Hereâ€™s a breakdown of a Rotation and Scale animation workflow:

<Steps>
1. Get the animation time (0 to 1 range) using the time node.

2. Create a smoothing effect by connecting the time to Easing node. For example, use Elastic easing for a bounce effect.

3. Combine rotation and scaling:
    - Scale: Connect the eased time directly. This makes the object grow from invisible (0) to full size (1).
    - Rotation: Multiply the eased time by 360 so the object rotates one full turn.

4. Combine effects using a Matrix Input Node. This allows scale and rotation to be applied together.
Your node connection should look like the ones in the image below
  <Image src={sophGraphImg} alt="Simple graph that connects Normalized Time of Time Node to Layer's Opacity input"/>

</Steps>

The result is a smooth, rotating, and scaling animation, perfect for attention-grabbing effects.

  <video src={bopVideo} muted autoplay loop/>




## Key takeaways

- Procedural animations give you fine control over timing and transitions.
- Experimentation is key. Try combining nodes in creative ways.
- The more comfortable you get with nodes, the faster you can create unique, dynamic effects.



## Further learning
To learn more:
- <a href="/docs/usage/node-graph/nodes/animation/easing">Easing</a> 
- <a href="/docs/usage/node-graph/nodes/animation/time#normalized-time">Normalized time</a>
- <a href="/docs/usage/node-graph/property-sockets/#-matrix3x3">Matrix</a> 

